N = int(input())
tree = [[] for _ in range(N + 1)]  # 인접 리스트 방식

##인접 리스트
#print("트리의 구조는 :", tree) [[],[],[],[],[],[],[],[],[],[],[],[],[],[]] 인덱스 0부터 시작.
#1부터 12를 표현하기 위해.
#[] [2, 3] [1, 4] [1, 5, 6] [2, 7, 8] [3, 9, 10] [3, 11, 12] [4] [4] [5] [5] [6] [6]
#연결된 노드가 써진다. append 사용.


##인접 행렬
#[[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0],
# [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0],
# [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]
#각 번째 리스트 당 인덱스 별로 연결되어 있으면 1이 쓰인다.
for _ in range(N - 1): #간선의 수만큼
    a, b = map(int, input().split())
    tree[a].append(b) #연결된 노드를 리스트에 넣는다.
    tree[b].append(a)
##트리 요소 출력
'''
for i in range(N + 1):
    print(tree[i], end=" ")
[] [2, 3] [1, 4] [1, 5, 6] [2, 7, 8] [3, 9, 10] [3, 11, 12] [4] [4] [5] [5] [6] [6]
'''
queue = [1]  # 시작노드 넣기. 넓이 우선 탐색 시 
visited = [0] * (N + 1) #[0,0,0,0,0,0,0,0,0,0,0,0,0]
result = {} #딕셔너리 선언 자식 노드가 키, 부모 노드를 value로 쓸 것이다. 트리일 때 딕셔너리 사용.
## 부모저장 parents = [0 for _ in range(N + 1)]

#BFS 특징
while queue: #queue가 남아있을 때까지
    now = queue.pop(0) #앞서 queue에 시작값을 넣었다.(while문의 초기값). 그리고 그것을 pop. queue의 경우 탐색 기준값이 pop되어야 한다.
    for i in tree[now]: #첫번째로는 1의 리스트 요소들을 검색한다. 1은 2와 3이 연결되어 있다.
        if visited[i] == 0: #처음 방문일때만 부모를 매칭할 것이다. i는 현재 2인 상태.
            result[i] = now  # result는 딕셔너리. 따라서 key인 i(2)의 value에 현재 연결된 노드를 붙여준다.
            visited[i] = 1  # 방문 처리를 한다.
            queue.append(i)  # 큐에 추가(이제 막 방문했고,부모 노드가 매칭된 것을 queue로 넣는다.)
for i in range(2, N + 1):
    print(result[i])
''''
1
1
2
3
3
4
4
5
5
6
6
'''
#print(result)  --> 딕셔너리인 result의 전체를 출력한다.
#{2: 1, 3: 1, 1: 2, 4: 2, 5: 3, 6: 3, 7: 4, 8: 4, 9: 5, 10: 5, 11: 6, 12: 6}
